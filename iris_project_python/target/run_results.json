{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.2", "generated_at": "2025-02-25T20:44:00.211373Z", "invocation_id": "f9ed359e-734f-4e81-8d03-2d0c2c5c009d", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-25T20:44:00.161282Z", "completed_at": "2025-02-25T20:44:00.196028Z"}, {"name": "execute", "started_at": "2025-02-25T20:44:00.196513Z", "completed_at": "2025-02-25T20:44:00.196529Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.036711692810058594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.iris_python_project.1_bronze", "compiled": true, "compiled_code": "# models/bronze.py\nimport pandas as pd\nimport os\n\ndef model(dbt, session):\n    # Caminho para o CSV de ingest\u00e3o (gerado previamente)\n    csv_path = os.path.join(\"data\", \"bronze\", \"iris.csv\")\n    \n    # L\u00ea o CSV com pandas\n    df = pd.read_csv(csv_path)\n    \n    # Opcional: renomeia as colunas para remover espa\u00e7os e caracteres especiais\n    df.columns = [col.strip().replace(\" \", \"_\").replace(\"(\", \"\").replace(\")\", \"\") for col in df.columns]\n    \n    # (Opcional) Salva um CSV \"limpo\" para refer\u00eancia, se necess\u00e1rio\n    os.makedirs(\"data/bronze\", exist_ok=True)\n    clean_csv = os.path.join(\"data\", \"bronze\", \"iris_clean.csv\")\n    df.to_csv(clean_csv, index=False)\n    \n    return df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"db\"\n    schema = \"main\"\n    identifier = \"1_bronze\"\n    \n    def __repr__(self):\n        return '\"db\".\"main\".\"1_bronze\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "\"db\".\"main\".\"1_bronze\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-25T20:44:00.199020Z", "completed_at": "2025-02-25T20:44:00.201998Z"}, {"name": "execute", "started_at": "2025-02-25T20:44:00.202463Z", "completed_at": "2025-02-25T20:44:00.202472Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.0047454833984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.iris_python_project.2_silver", "compiled": true, "compiled_code": "# models/silver.py\nimport pandas as pd\nimport os\n\ndef model(dbt, session):\n    # Caminho para o CSV limpo da camada bronze\n    bronze_csv = os.path.join(\"data\", \"bronze\", \"iris_clean.csv\")\n    df = pd.read_csv(bronze_csv)\n    \n    # Cria novas colunas de transforma\u00e7\u00e3o\n    # Exemplo: \u00e1rea da s\u00e9pala e \u00e1rea da p\u00e9tala\n    df[\"sepal_area\"] = df[\"sepal_length_cm\"] * df[\"sepal_width_cm\"]\n    df[\"petal_area\"] = df[\"petal_length_cm\"] * df[\"petal_width_cm\"]\n    \n    # Cria o diret\u00f3rio da camada silver, se necess\u00e1rio\n    os.makedirs(\"data/silver\", exist_ok=True)\n    silver_csv = os.path.join(\"data\", \"silver\", \"iris_silver.csv\")\n    df.to_csv(silver_csv, index=False)\n    \n    return df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"db\"\n    schema = \"main\"\n    identifier = \"2_silver\"\n    \n    def __repr__(self):\n        return '\"db\".\"main\".\"2_silver\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "\"db\".\"main\".\"2_silver\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-25T20:44:00.204823Z", "completed_at": "2025-02-25T20:44:00.207620Z"}, {"name": "execute", "started_at": "2025-02-25T20:44:00.208102Z", "completed_at": "2025-02-25T20:44:00.208109Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.004497528076171875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.iris_python_project.3_gold", "compiled": true, "compiled_code": "# models/gold.py\nimport pandas as pd\nimport numpy as np\nimport os\n\ndef model(dbt, session):\n    # L\u00ea o CSV da camada silver\n    silver_csv = os.path.join(\"data\", \"silver\", \"iris_silver.csv\")\n    df = pd.read_csv(silver_csv)\n    \n    # Cria a coluna 'split' com 70% para treino e 30% para teste\n    np.random.seed(42)\n    df[\"split\"] = np.where(np.random.rand(len(df)) < 0.7, \"train\", \"test\")\n    \n    # Cria o diret\u00f3rio da camada gold, se necess\u00e1rio, e salva o CSV gold completo\n    os.makedirs(\"data/gold\", exist_ok=True)\n    gold_csv = os.path.join(\"data\", \"gold\", \"iris_gold.csv\")\n    df.to_csv(gold_csv, index=False)\n    \n    return df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"db\"\n    schema = \"main\"\n    identifier = \"3_gold\"\n    \n    def __repr__(self):\n        return '\"db\".\"main\".\"3_gold\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "\"db\".\"main\".\"3_gold\"", "batch_results": null}], "elapsed_time": 0.15168309211730957, "args": {"log_format_file": "debug", "log_level_file": "debug", "send_anonymous_usage_stats": true, "state_modified_compare_vars": false, "static": false, "strict_mode": false, "partial_parse_file_diff": true, "quiet": false, "exclude": [], "log_format": "default", "log_level": "info", "indirect_selection": "eager", "require_nested_cumulative_type_params": false, "use_colors_file": true, "require_resource_names_without_spaces": false, "macro_debugging": false, "skip_nodes_if_on_run_start_fails": false, "which": "generate", "source_freshness_run_project_hooks": false, "cache_selected_only": false, "log_file_max_bytes": 10485760, "require_yaml_configuration_for_mf_time_spines": false, "select": [], "version_check": true, "print": true, "state_modified_compare_more_unrendered_values": false, "static_parser": true, "use_colors": true, "warn_error_options": {"include": [], "exclude": []}, "introspect": true, "log_path": "/home/patrick/dbt_study/iris_project_python/logs", "vars": {}, "write_json": true, "printer_width": 80, "favor_state": false, "empty_catalog": false, "invocation_command": "dbt docs generate", "defer": false, "partial_parse": true, "populate_cache": true, "project_dir": "/home/patrick/dbt_study/iris_project_python", "show_resource_report": false, "profiles_dir": "/home/patrick/dbt_study/iris_project_python", "require_batched_execution_for_custom_microbatch_strategy": false, "compile": true, "require_explicit_package_overrides_for_builtin_materializations": true}}